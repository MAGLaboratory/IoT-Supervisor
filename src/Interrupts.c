//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>
#include "PetitModBus.h"

// externs for modbus are somewhat on PetitModBusPort.h
extern bool modbusRunFlag;


// externs for state machine
extern bool smRunFlag;
extern bool cprif;
extern bool VinCmp;
extern bool nReset;
extern void VinSm(void);

//-----------------------------------------------------------------------------
// CMP0_ISR
//-----------------------------------------------------------------------------
//
// CMP0 ISR Content goes here. Remember to clear flag bits:
// CMP0CN0::CPFIF (Comparator Falling-Edge Flag)
// CMP0CN0::CPRIF (Comparator Rising-Edge Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (CMP0_ISR, CMP0_IRQn)
{
	// state machine immediate off
	// clear falling edge flag (should not trigger to but whatever)
	if (CMP0CN0 & CMP0CN0_CPFIF__BMASK)
	{
		CMP0CN0 &= ~(CMP0CN0_CPFIF__BMASK);
	}
	// clear rising edge flag
	if (CMP0CN0 & CMP0CN0_CPRIF__BMASK)
	{
		CMP0CN0 &= ~(CMP0CN0_CPRIF__BMASK);
		cprif = true;
		smRunFlag = true;
	}
}

//-----------------------------------------------------------------------------
// TIMER0_ISR
//-----------------------------------------------------------------------------
//
// TIMER0 ISR Content goes here. Remember to clear flag bits:
// TCON::TF0 (Timer 0 Overflow Flag)
//
// ISR for modbus (1.75 ms or whatever)
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
{
	TCON_TF0 = 0;
	TL0 = (0xC7 << TL0_TL0__SHIFT);
	// some modbus switch-on and transmission
	modbusRunFlag = true;
}

//-----------------------------------------------------------------------------
// TIMER1_ISR
//-----------------------------------------------------------------------------
//
// TIMER1 ISR Content goes here. Remember to clear flag bits:
// TCON::TF1 (Timer 1 Overflow Flag)
//
// ISR for for timing (8 ms)
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER1_ISR, TIMER1_IRQn)
{
	TCON_TF1 = 0;
	TH0 = (0x01 << TH0_TH0__SHIFT);
	smRunFlag = true;
}

//-----------------------------------------------------------------------------
// UART0_ISR
//-----------------------------------------------------------------------------
//
// UART0 ISR Content goes here. Remember to clear flag bits:
// RI::SCON0 (UART 0 Receive Flag)
// TI::SCON0 (UART 0 Transmit Flag)
//
// ISR for for UART
//-----------------------------------------------------------------------------
SI_INTERRUPT (UART0_ISR, UART0_IRQn)
{
	//Buffer and clear flags immediately so we don't miss an interrupt while processing
	uint8_t flags = SCON0 & (SCON0_RI__BMASK | SCON0_TI__BMASK);
	SCON0 &= ~flags;

	if (PetitRxRemaining && (flags & SCON0_RI__SET))
	{
		*Petit_Rx_Ptr++ = SBUF0;
		PetitRxCounter++;
		if (!--PetitRxRemaining)
		{
			//UART0_receiveCompleteCb();
		}
	}

	if ((flags & SCON0_TI__SET))
	{
		if (Petit_Tx_Buf_Size)
		{
			SBUF0 = *Petit_Tx_Ptr++;
			Petit_Tx_Buf_Size--;
		}
		else
		{
			// Petit Modbus Tx Complete
			Petit_Tx_State = PETIT_RXTX_IDLE;
		}
	}
}
