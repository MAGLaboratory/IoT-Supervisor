/******************************************************************************
 * @file Interrupts.c
 * generated by Hardware Configurator
 *
 * This file contains interrupt service routines.
 *
 * This file will be regenerated when saving a document.
 * leave the sections inside the "$[...]" comment tags alone
 * or they will be overwritten!
 *****************************************************************************/

// USER INCLUDES
#include "hardware.h"
#include <SI_EFM8BB1_Register_Enums.h>
#include "PetitModbusPort.h"
#include "IoT_Supervisor.h"

#define WDT_RESET() (WDTCN = 0xA5)

/**
 * @defgroup Application_Interrupts Application Interrupts
 * @{
 */

/******************************************************************************
 * CMPn ISR Content goes here. Remember to clear flag bits:
 * - CMPnCN0::CPFIF (Comparator Falling-Edge Flag)
 * - CMPnCN0::CPRIF (Comparator Rising-Edge Flag)
 *
 * This ISR implements the immediate voltage low reset for the SBC.
 *****************************************************************************/
SI_INTERRUPT (CMP1_ISR, CMP1_IRQn)
{
	static bool firstInterrupt = true;
	// state machine immediate off
	// clear falling edge flag (should not trigger to but whatever)
	if (CMP1CN0 & CMP1CN0_CPFIF__BMASK)
	{
		CMP1CN0 &= ~(CMP1CN0_CPFIF__BMASK);
	}
	// clear rising edge flag
	// run the Vin state machine to shut down the IoT device
	if (CMP1CN0 & CMP1CN0_CPRIF__BMASK)
	{
		CMP1CN0 &= ~(CMP1CN0_CPRIF__BMASK);
		// interrupt fires once on startup
		if (firstInterrupt)
			firstInterrupt = false;
		else
		{
			RESET_P = false; // reset now.
			nLED = false; // light led
			cprif = true;
		}
	}
}

/******************************************************************************
 * @fn SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
 ******************************************************************************
 *
 * TIMER0 ISR Content goes here. Remember to clear flag bits:
 * - TCON::TF0 (Timer 0 Overflow Flag)
 *
 * ISR for modbus message timeout
 *
 * @note This is actually the timer 0 low ISR since timer0 is split into two
 * 		timers.
 *
 * Modbus implements a "T_1.5" timeout between bytes.  Clearing the data in
 * the modbus buffer invalidates it.
 *****************************************************************************/
SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
{
	TCON_TF0 = 0;

	TIMER0_PINO_ON();

	// reset timer counter
	TL0 = (0x20 << TL0_TL0__SHIFT);

	// this timer implements both a software and a hardware timer.
	// multiple counts of the software timer are used for slower modbus speeds
	t0Count++;
	if (t0Count > T0C_TOP)
	{
		TIMER0_PINI_ON();
		// reset timer counter (should be a define)
		PetitPortTimerStop();

		// clear the modbus receiver
		PetitRxBufferReset();

		// transceiver on receive mode
		PetitPortDirRx();

		TIMER0_PINI_OFF();
	}
	TIMER0_PINO_OFF();
}

/******************************************************************************
 * @fn SI_INTERRUPT (TIMER1_ISR, TIMER1_IRQn)
 ******************************************************************************
 *
 * TIMER1 ISR Content goes here. Remember to clear flag bits:
 * - TCON::TF1 (Timer 1 Overflow Flag)
 *
 * ISR for for timing (1 ms)
 *
 * Actually the timer 0 high ISR since timer0 is split into two timers.
 *
 * This is more or less the main timing source for the functions on
 * this application.
 *****************************************************************************/
SI_INTERRUPT (TIMER1_ISR, TIMER1_IRQn)
{
	static unsigned char t1c = 0;
	TCON_TF1 = 0;

	TH0 = (0x80 << TH0_TH0__SHIFT);

	TIMER1_PIN_ON();

	t1Count++;

	// run every 8ms
	if ((t1c & 7) == 0)
	{
		VinSm();
		mbWDTsm();
		WDT_RESET();
	}
	t1c++;

	TIMER1_PIN_OFF();
}

/******************************************************************************
 * @fn SI_INTERRUPT (UART0_ISR, UART0_IRQn)
 ******************************************************************************
 * UART0 ISR Content goes here. Remember to clear flag bits:
 * - RI::SCON0 (UART 0 Receive Flag)
 * - TI::SCON0 (UART 0 Transmit Flag)
 *
 * ISR for for UART
 *
 * On UART receive, this ISR is called to insert the received byte into the
 * petit modbus buffer.
 *
 * On UART transmit, this ISR is called to start transmitting the next byte
 *
 * @note both UART transmit and UART receive interrupts are implemented here
 *****************************************************************************/
SI_INTERRUPT (UART0_ISR, UART0_IRQn)
{
	//Buffer and clear flags immediately so we don't miss an interrupt while processing
	uint8_t flags = SCON0 & (SCON0_RI__BMASK | SCON0_TI__BMASK);
	SCON0 &= ~flags;

	UART0_PIN_ON();

	if (flags & SCON0_RI__SET)
	{
		PetitRxBufferInsert(SBUF0);
	}

	if (flags & SCON0_TI__SET)
	{
		unsigned char res;
		if (PetitTxBufferPop(&res))
		{
			SBUF0 = res;
		}
		else
		{
			PetitPortDirRx();
		}
	}

	UART0_PIN_OFF();
}

/******************************************************************************
 * @fn SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
 ******************************************************************************
 *
 * ADC0EOC ISR Content goes here. Remember to clear flag bits:
 * - ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
 *
 * ADC0 End of Conversion ISR
 *
 * This ISR is called when the ADC finishes converting.  In this application,
 * it should be configured for every 50ms or so.
 *****************************************************************************/
SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
{
	char conv_count;
	ADC0CN0_ADINT = 0;					// clear interrupt flag

	ADC0_PIN_ON();

	// top 6 bits for the conversion count
	// bottom 10 bits for the ADC value (it's a 10-bit ADC)
	conv_count = PetitInputRegisters[0] >> 10 & 0x3F;
	conv_count++;
	PetitInputRegisters[0] = (uint16_t) conv_count << 10 | ADC0 >> 6;

	ADC0_PIN_OFF();
}

// group Application Interrupts
/**
 * @}
 */
