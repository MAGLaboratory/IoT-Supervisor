//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>
#include "PetitModBus.h"

// externs flags
extern unsigned char t1Flag;
extern bool cprif;

void VinSm (void);

#define WDT_RESET() (WDTCN = 0xA5)

//-----------------------------------------------------------------------------
// CMP0_ISR
//-----------------------------------------------------------------------------
//
// CMP0 ISR Content goes here. Remember to clear flag bits:
// CMP0CN0::CPFIF (Comparator Falling-Edge Flag)
// CMP0CN0::CPRIF (Comparator Rising-Edge Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (CMP0_ISR, CMP0_IRQn)
{
	// state machine immediate off
	// clear falling edge flag (should not trigger to but whatever)
	if (CMP0CN0 & CMP0CN0_CPFIF__BMASK)
	{
		CMP0CN0 &= ~(CMP0CN0_CPFIF__BMASK);
	}
	// clear rising edge flag
	// run the Vin state machine to shut down the IoT device
	if (CMP0CN0 & CMP0CN0_CPRIF__BMASK)
	{
		CMP0CN0 &= ~(CMP0CN0_CPRIF__BMASK);
		cprif = true;
		VinSm();
	}
}

//-----------------------------------------------------------------------------
// TIMER0_ISR (timer 0, low)
//-----------------------------------------------------------------------------
//
// TIMER0 ISR Content goes here. Remember to clear flag bits:
// TCON::TF0 (Timer 0 Overflow Flag)
//
// ISR for modbus message timeout
//
// Modbus implements a 1.75ms timeout between messages.  Clearing the data in
// the modbus buffer invalidates it.
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
{
	TCON_TF0 = 0;
	// timer off
	// reset timer counter (should be a define)
	TCON_TR0 = false;
	TL0 = (0x20 << TL0_TL0__SHIFT);

	// clear the modbus receiver
	PetitRxCounter = 0;
	PetitRxRemaining = PETITMODBUS_RECEIVE_BUFFER_SIZE;
	Petit_Rx_Ptr = &(PetitRxBuffer[0]);
	PetitExpectedReceiveCount = 0;
}

//-----------------------------------------------------------------------------
// TIMER1_ISR (timer 0, high)
//-----------------------------------------------------------------------------
//
// TIMER1 ISR Content goes here. Remember to clear flag bits:
// TCON::TF1 (Timer 1 Overflow Flag)
//
// ISR for for timing (1 ms)
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER1_ISR, TIMER1_IRQn)
{
	static unsigned char t1c = 0;
	TCON_TF1 = 0;
	TH0 = (0x80 << TH0_TH0__SHIFT);
	t1Flag++;

	if ((t1c & 7) == 0)
	{

		WDT_RESET();
	}
	t1c++;
}

//-----------------------------------------------------------------------------
// UART0_ISR
//-----------------------------------------------------------------------------
//
// UART0 ISR Content goes here. Remember to clear flag bits:
// RI::SCON0 (UART 0 Receive Flag)
// TI::SCON0 (UART 0 Transmit Flag)
//
// ISR for for UART
//-----------------------------------------------------------------------------
SI_INTERRUPT (UART0_ISR, UART0_IRQn)
{
	//Buffer and clear flags immediately so we don't miss an interrupt while processing
	uint8_t flags = SCON0 & (SCON0_RI__BMASK | SCON0_TI__BMASK);
	SCON0 &= ~flags;

	if (PetitRxRemaining && (flags & SCON0_RI__SET))
	{
		char read = SBUF0;
		if (!PetitRxCounter)
		{
			// check if servant address is correct on first character
			if (read == 1)
			{
				*Petit_Rx_Ptr++ = read;
				PetitRxRemaining--;
				PetitRxCounter++;
				TL0 = (0x20 << TL0_TL0__SHIFT);
				TCON_TR0 = true;
			}
		}
		else
		{
			*Petit_Rx_Ptr++ = read;
			PetitRxRemaining--;
			PetitRxCounter++;
			TL0 = (0x20 << TL0_TL0__SHIFT);
			TCON_TR0 = true;
		}
	}

	if ((flags & SCON0_TI__SET))
	{
		if (Petit_Tx_Buf_Size)
		{
			SBUF0 = *Petit_Tx_Ptr++;
			Petit_Tx_Buf_Size--;
		}
		else
		{
			// Petit Modbus Tx Complete
			Petit_Tx_State = PETIT_RXTX_IDLE;
		}
	}
}
